<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0073)http://www.classes.cs.uchicago.edu/archive/2013/spring/12300-1/labs/lab6/ -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="Docutils 0.10: http://docutils.sourceforge.net/">
<title>Concurrency in C++11</title>
<style type="text/css">

/*
For use with rst2html.py. Use add --stylesheet=rst.css to rst2html.py to use.

:Author: David Goodger (goodger@python.org)
:Modified by: Gustav Larsson

:Id: $Id: html4css1.css 7056 2011-06-17 10:50:48Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; 
}

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: left 
}

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math {
    margin-left: 0.5em ;
    margin-right: 0.5em ;
    border: 1px solid rgb(200, 200, 200);
    color: rgb(51, 51, 51);
    border-radius: 3px;
    background-color: rgb(248, 248, 248);
    padding-left: 8px;
    padding-right: 8px;
    padding-top: 4px;
    padding-bottom: 4px;
}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
}

ul.auto-toc {
  list-style-type: none }

/* Some modifications */

html, body {
    font-family: Helvetica, arial, freesans, clean, sans-serif;
    line-height: 160%;
    font-size: 14px;
}

div.document {
    width: 800px;
}

h1 { font-size: 28px }
div.section h1 { 
    font-size: 24px;
    border-bottom: 1px solid rgb(204, 204, 204); 
    line-height: 180%;
}
h2 { 
    font-size: 20px 
    line-height: 160%;
}
h3 { font-size: 18px }
h4 { font-size: 16px }
h5 { font-size: 14px }

p tt, li tt {
    border: 1px solid rgb(234, 234, 234);
    color: rgb(51, 51, 51);
    border-radius: 3px;
    background-color: rgb(248, 248, 248);
    font-family: Consolas, 'Liberation Mono', Courier, monospace;
    margin-left: 2px;
    margin-right: 2px;
    padding-left: 5px;
    padding-right: 5px;
}

h2 tt {
    font-size: 20px;    
}

a {
    text-decoration: none;
    color: rgb(65, 131, 196);
}

a:hover {
    text-decoration: underline; 
}

div.note, div.warning {
    border: 1px solid rgb(214, 214, 204);
    color: rgb(51, 51, 51);
    border-radius: 3px;
    background-color: rgb(248, 248, 238);
    margin-left: 1em;
    margin-right: 1em;
    padding-left: 8px;
    padding-right: 8px;
    padding-top: 4px;
    padding-bottom: 4px;
}

</style>
<style type="text/css"></style></head>
<body>
<div class="document" id="concurrency-in-c-11">
<h1 class="title">Concurrency in C++11</h1>

<p>In this lab you will learn the basics of running concurrent threads with shared memory. You will also get some general exposure to C++11, which is the latest incarnation of the C++ programming language.</p>
<ul class="simple">
<li>C++11</li>
<li>Shared memory parallelization</li>
</ul>
<blockquote>
<ul class="simple">
<li>Threads</li>
<li>Race conditions</li>
<li>Mutexes</li>
<li>Atomicity</li>
<li>Asynchronous tasks</li>
<li>Condition variables</li>
</ul>
</blockquote>
<ul class="simple">
<li>Producer-consumer problem</li>
</ul>
<div class="section" id="resources">
<h1>Resources</h1>
<ul class="simple">
<li><a class="reference external" href="https://github.com/uchicago-cs/cmsc12300/tree/master/examples/cpp/concurrency/simple">Concurrency examples</a> - Examples of concurrency in C++11 and other languages.</li>
<li><a class="reference external" href="http://en.cppreference.com/w/cpp">C++ reference</a> - Standard library reference that clearly marks what is new in C++11</li>
</ul>
</div>
<div class="section" id="c-11">
<h1>C++11</h1>
<p>C++11 is the latest C++ standard that was published in 2011. Before it was published, it was known as C++0x. There are still plenty of old references using this name and you should consider them synonymous. The standard is only a long document with specifications and it is up to various groups to implement compilers that conform to this standard.</p>
<p>Currently, GCC 4.8.1 supports almost all core features of C++11 (<a class="reference external" href="http://gcc.gnu.org/projects/cxx0x.html">GCC C++11 status</a>). C++11 is tightly coupled with its standard library, where many features are still missing (<a class="reference external" href="http://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.200x">libstdc++ status</a>). As of very recently, another popular open-source compiler, Clang, now has full C++11 support both in core functionality (<a class="reference external" href="http://clang.llvm.org/cxx_status.html">Clang C++11 status</a>) and its own version of the standard library (<a class="reference external" href="http://libcxx.llvm.org/">libc++ status</a>).</p>
<p>The lab computers only have GCC 4.6, but we have made sure you can run this lab. However, if you read tutorials on C++11 and can't seem to get things to compile, it might be because your compiler lacks the necessary support. That being said, GCC doesn't even fully support the C++98 or the C++03 standards, so let's not worry too much about that.</p>
<p>One thing that C++11 and its standard library vastly improves is concurrent programming, so let's dive in.</p>
<div class="section" id="threads">
<h2>Threads</h2>
<p>Creating threads is easy:</p>
<pre class="literal-block">#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std;

void func(int x) {
    cout &lt;&lt; "Inside thread " &lt;&lt; x &lt;&lt; endl;
}

int main() {
    thread th(&amp;func, 100);
    th.join();
    cout &lt;&lt; "Outside thread" &lt;&lt; endl;
    return 0;
}
</pre>
<p>Copy this to <tt class="docutils literal">main.cpp</tt> and compile it by running:</p>
<pre class="literal-block">$ g++ -std=c++0x main.cpp -pthread
</pre>
<p>Note that we have to specify that we want to use C++11, but we're using its old name since we have an old version of GCC. We also have to specify <tt class="docutils literal"><span class="pre">-pthread</span></tt>, since the implementation for our GCC uses something called <em>pthreads</em> as its backend. Make sure it compiles and runs.</p>
</div>
<div class="section" id="race-conditions">
<h2>Race conditions</h2>
<p>Let us imagine that <tt class="docutils literal">x * x</tt> is a very costly operation (it's not, but use your imagination) and we want to calculate the sum of squares up to a certain number. It would make sense to parallelize the calulation of each square across threads. We can do something like this:</p>
<pre class="literal-block">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;thread&gt;
using namespace std;

int accum = 0;

void square(int x) {
    accum += x * x;
}

int main() {
    vector&lt;thread&gt; ths;
    for (int i = 1; i &lt;= 20; i++) {
        ths.push_back(thread(&amp;square, i));
    }

    for (auto&amp; th : ths) {
        th.join();
    }
    cout &lt;&lt; "accum = " &lt;&lt; accum &lt;&lt; endl;
    return 0;
}
</pre>
<p>This should sum all squares up to and including 20. We iterate up to 20, and launch a new thread in each iteration that we give the assignment to. After this, we call <tt class="docutils literal">join()</tt> on all our threads, which is a blocking operation that waits for the thread to finish, before continuing the execution. This is important to do before we print <tt class="docutils literal">accum</tt>, since otherwise our threads might not be done yet. You should always join your threads before leaving <tt class="docutils literal">main</tt>, if you haven't already.</p>
<p>Before moving on, also note that C++11 offers more terse iteration syntax of the <tt class="docutils literal">vector</tt> class, very close in syntax to Java. We are also using the keyword <tt class="docutils literal">auto</tt> instead of specifying the data type <tt class="docutils literal">thread</tt>, which we can do whenever the compiler can unambiguously guess what the correct type should be. We added an <tt class="docutils literal">&amp;</tt> to retrieve a reference and not a copy of the object, since <tt class="docutils literal">join</tt> changes the nature of the object.</p>
<p>Now, run this. Chances are it spits out 2870, which is the correct answer.</p>
<p>Let's use our bash shell to run it a few more times (assuming you compiled it to <tt class="docutils literal">a.out</tt>):</p>
<pre class="literal-block">$ for i in {1..40}; do ./a.out; done
</pre>
<p>See any inconsistencies yet? Better yet, let's list all distinct outputs from 1000 separate runs, including the count for each output:</p>
<pre class="literal-block">$ for i in {1..1000}; do ./a.out; done | sort | uniq -c
</pre>
<p>You should definitely see plenty of incorrect answers, even though most of the time it gets it right. This is because of something called a <em>race condition</em>. When the compiler processes <tt class="docutils literal">accum += x * x;</tt>, reading the current value of <tt class="docutils literal">accum</tt> and setting the updated value is not an atomic (meaning indivisible) event. Let's re-write <tt class="docutils literal">square</tt> to capture this:</p>
<pre class="literal-block">int temp = accum;
temp += x * x;
accum = temp;
</pre>
<p>Now, let's say the first two threads are interleaved over time, giving us something like this:</p>
<pre class="literal-block">// Thread 1             // Thread 2
int temp1 = accum;      int temp2 = accum;          // temp1 = temp2 = 0
                        temp2 += 2 * 2;             // temp2 = 4
temp1 += 1 * 1;                                     // temp1 = 1
                        accum = temp1;              // accum = 1
accum = temp2;                                      // accum = 4
</pre>
<p>We end up with <tt class="docutils literal">accum</tt> as 4, instead of the correct 5.</p>
<p><strong>Exercise:</strong></p>
<ul class="simple">
<li>Before we fix the race condition, since keeping <tt class="docutils literal">accum</tt> as a global variable is poor style, we would rather pass it into the thread. You already know how to pass variables, so add a parameter <tt class="docutils literal">int&amp; accum</tt> to <tt class="docutils literal">square</tt>. It is important that it's a reference, since we want to be able to change the accumulator. However, we can't simply call <tt class="docutils literal"><span class="pre">thread(&amp;square,</span> accum, i)</tt>, since it will make a copy of <tt class="docutils literal">accum</tt> and then call <tt class="docutils literal">square</tt> with that copy. To fix this, we wrap <tt class="docutils literal">accum</tt> in <tt class="docutils literal">ref()</tt>, making it <tt class="docutils literal"><span class="pre">thread(&amp;square,</span> ref(accum), i)</tt>.</li>
</ul>
</div>
<div class="section" id="mutex">
<h2>Mutex</h2>
<p>A <em>mutex</em> (<strong>mut</strong>ual <strong>ex</strong>lusion) allows us to encapsulate blocks of code that should only be executed in one thread at a time. Keeping the <tt class="docutils literal">main</tt> function the same:</p>
<pre class="literal-block">int accum = 0;
mutex accum_mutex;

void square(int x) {
    int temp = x * x;
    accum_mutex.lock();
    accum += temp;
    accum_mutex.unlock();
}
</pre>
<p>Try running the program repeatedly again and the problem should now be fixed. The first thread that calls <tt class="docutils literal">lock()</tt> gets the lock. During this time, all other threads that call <tt class="docutils literal">lock()</tt>, will simply halt, waiting at that line for the mutex to be unlocked. It is important to introduce the variable <tt class="docutils literal">temp</tt>, since we want the <tt class="docutils literal">x * x</tt> calculations to be outside the lock-unlock block, otherwise we would be hogging the lock while we're running our calculations.</p>
<!-- Commented out, not that important.

A convenient class is the ``lock_guard``, which takes the mutex and locks it, and unlocks it when the ``lock_guard`` exits scope and is destroyed. This way, the ``unlock`` is implicitly performed at the end of the current scope::

    void square(int x) {
        int temp = x * x;
        lock_guard<mutex> lock(accum_mutex);
        accum = temp;
    } -->
</div>
<div class="section" id="atomic">
<h2>Atomic</h2>
<p>C++11 offers even nicer abstractions to solve this problem. For instance, the <tt class="docutils literal">atomic</tt> container:</p>
<pre class="literal-block">#include &lt;atomic&gt;

atomic&lt;int&gt; accum(0);

void square(int x) {
    accum += x * x;
}
</pre>
<p>We don't need to introduce <tt class="docutils literal">temp</tt> here, since <tt class="docutils literal">x * x</tt> will be evaluated before handed off to <tt class="docutils literal">accum</tt>, so it will be outside the atomic event.</p>
</div>
<div class="section" id="tasks">
<h2>Tasks</h2>
<p>An even higher level of abstraction avoids the concept of threads altogether and talks in terms of <em>tasks</em> instead. Consider the following example:</p>
<pre class="literal-block">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;chrono&gt;
using namespace std;

int square(int x) {
    return x * x;
}

int main() {
    auto a = async(&amp;square, 10);
    int v = a.get();

    cout &lt;&lt; "The thread returned " &lt;&lt; v &lt;&lt; endl;
    return 0;
}
</pre>
<p>The <tt class="docutils literal">async</tt> construct uses an object pair called a <em>promise</em> and a <em>future</em>. The former has made a promise to eventually provide a value. The future is linked to the promise and can at any time try to retrieve the value by <tt class="docutils literal">get()</tt>. If the promise hasn't been fulfilled yet, it will simply wait until the value is ready. The <tt class="docutils literal">async</tt> hides most of this for us, except that it returns in this case a <tt class="docutils literal">future&lt;int&gt;</tt> object. Again, since the compiler knows what this call to <tt class="docutils literal">async</tt> returns, we can use <tt class="docutils literal">auto</tt> to declare the future.</p>
<p><strong>Exercise:</strong></p>
<ul class="simple">
<li>Use <tt class="docutils literal">async</tt> to solve the sum of squares problem. Iterate up to 20 and add your <tt class="docutils literal">future&lt;int&gt;</tt> objects to a <tt class="docutils literal">vector&lt;future&lt;int&gt;&gt;</tt>. Then, finally iterate all your futures and retrieve the value and add it to your accumulator. This should be only a few modifications from the code above.</li>
</ul>
</div>
<div class="section" id="this-thread">
<h2><tt class="docutils literal">this_thread</tt></h2>
<p>Let's make sure this really runs in parallel. Using the code from the last exercise, now add a <tt class="docutils literal">cout</tt> that prints <tt class="docutils literal">x</tt> inside <tt class="docutils literal">square</tt>. Run your program again. Every time you run it, it should be listing the values of <tt class="docutils literal">x</tt> in order. This seems awfully deterministic and is not characteristic of running things in parallel. We did start them in that order, so maybe the threads aren't overtaking each other. We can check this by adding a sleep inside <tt class="docutils literal">square</tt>, which we can pretend is the heavy computation of <tt class="docutils literal">x * x</tt>:</p>
<pre class="literal-block">this_thread::sleep_for(chrono::milliseconds(100));
</pre>
<p>Note that all these seemingly global objects are in the <tt class="docutils literal">std</tt> namespace, but since we issued <tt class="docutils literal">using namespace std</tt>, we made them visible globally. Okay, run this and time the execution. They are clearly taking turns and they are not running in parallel. Use <tt class="docutils literal">cout</tt> to print <tt class="docutils literal"><span class="pre">this_thread::get_id()</span></tt>. Since the main execution is also considered a thread, try printing the thread ID inside <tt class="docutils literal">main</tt> using this same function. What does this tell you?</p>
<p>The function <tt class="docutils literal">async</tt> by default gives the program the option of running it <em>asynchronously</em> or <em>deferred</em>. The latter means <tt class="docutils literal">square</tt> will be called first when we call <tt class="docutils literal">get()</tt>, and it will be executed in the same thread. Ideally, the program should make an intelligent decision, optimized for performance, but for some reason GCC always defers, so let's not give it a choice about it. Change the call to <tt class="docutils literal">async</tt> as follows:</p>
<pre class="literal-block">async(launch::async, &amp;square, ...)
</pre>
<p>Run it again, timing the execution.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p>We got a 20 time speed up only because our threads aren't actually heavy on the CPU while sleeping, so it's not an ideal surrogate for imagining that <tt class="docutils literal">x * x</tt> actually takes 100 ms of CPU time. In the real case, the speed up would be largely determined by how many cores we have on our computer.</p>
<p class="last">Ideally, you should avoid starting more computationally intensive threads than your computer can truly run in parallel, since otherwise your CPU cores will start switching its attention between different threads. Each switch is called a <em>context switch</em> and comes with an overhead that will hurt performance.</p>
</div>
</div>
<div class="section" id="condition-variables">
<h2>Condition variables</h2>
<p>If we return to threads, it would be useful to be able to have one thread wait for another thread to finish processing something, essentially sending a signal between the threads. This can be done with mutexes, but it would be awkward. It can also be done using a global boolean variable called <tt class="docutils literal">notified</tt> that is set to <tt class="docutils literal">true</tt> when we want to send the signal. The other thread would then run a for loop that checks if <tt class="docutils literal">notified</tt> is <tt class="docutils literal">true</tt> and stops looping when that happens. Since setting <tt class="docutils literal">notified</tt> to <tt class="docutils literal">true</tt> is atomic and in this example we're only setting it once, we don't even need a mutex. However, on the receiving thread we are running a for loop at full speed, wasting a lot of CPU time. We could add a short <tt class="docutils literal">sleep_for</tt> inside the for loop, making the CPU idle most of the time.</p>
<p>A more principled way however is to add a call to <tt class="docutils literal">wait</tt> for a <em>condition variable</em> inside the for loop. The instructor will cover this in Thursday's class, so this will be sneak preview:</p>
<pre class="literal-block">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;condition_variable&gt;
#include &lt;mutex&gt;
#include &lt;chrono&gt;
#include &lt;queue&gt;
using namespace std;

condition_variable cond_var;
mutex m;

int main() {
    int value = 100;
    bool notified = false;
    thread reporter([&amp;]() {
        /*
        unique_lock&lt;mutex&gt; lock(m);
        while (!notified) {
            cond_var.wait(lock);
        }
        */
        cout &lt;&lt; "The value is " &lt;&lt; value &lt;&lt; endl;
    });

    thread assigner([&amp;]() {
        value = 20;
        /*
        notified = true;
        cond_var.notify_one();
        */
    });

    reporter.join();
    assigner.join();
    return 0;
}
</pre>
<p>First of all, we're using some new syntax from C++11, that enables us to define the thread functions in-place as anynomous functions. They are implicitly passed the local scope, so they can read and write <tt class="docutils literal">value</tt> and <tt class="docutils literal">notified</tt>. If you compile it as it is, it will output 100 most of the time. However, we want the reporter thread to wait for the assigner thread to give it the value 20, before outputting it. You can do this by uncommenting the two <tt class="docutils literal">/* ... */</tt> blocks in either thread function. In the assigner thread, it will set <tt class="docutils literal">notified</tt> to <tt class="docutils literal">true</tt> and send a signal through the condition variable <tt class="docutils literal">cond_var</tt>. In the reporter thread, we're looping as long as <tt class="docutils literal">notified</tt> is <tt class="docutils literal">false</tt>, and in each iteration we wait for a signal. Try running it, it should work.</p>
<p>But wait, if <tt class="docutils literal">cond_var</tt> can send a signal that will make the call <tt class="docutils literal">cond_var.wait(lock)</tt> blocking until it receives it, why are we still using <tt class="docutils literal">notified</tt> and a for loop? Well, that's because the condition variable can be spuriously awaken even if we didn't call <tt class="docutils literal">notify_one</tt>, and in those cases we need to fall back to checking <tt class="docutils literal">notified</tt>. This for loop will iterate that many times.</p>
<p>This is a simplified description since we are also giving <tt class="docutils literal">wait</tt> the object <tt class="docutils literal">lock</tt>, which is associated with a mutex <tt class="docutils literal">m</tt>. What happens is that when <tt class="docutils literal">wait</tt> is called, it not only waits for a notification, but also for the mutex <tt class="docutils literal">m</tt> to be unlocked. When this happens, it will acquire the lock itself. If <tt class="docutils literal">cond_var</tt> has acquired a lock and <tt class="docutils literal">wait</tt> is called again, it will be unlocked as long as it's waiting to acquire it again. This gives us some structure of mutual exclusion between the two threads, as we will see in the following example.</p>
</div>
<div class="section" id="producer-consumer-problem">
<h2>Producer-consumer problem</h2>
<p><em>Time permitting</em></p>
<p>You should now have all the tools needed to fix an instance of the <a class="reference external" href="http://en.wikipedia.org/wiki/Producer-consumer_problem">producer-consumer problem</a>. Simply put, one thread is producing goods and another thread is consuming goods. We want the consumer thread to wait using a condition variable, and we want <tt class="docutils literal">goods.push(i)</tt> to be mutually exclusive to <tt class="docutils literal">goods.pop()</tt>, so are data doesn't get corrupted. We are letting <tt class="docutils literal">c++</tt> and <tt class="docutils literal"><span class="pre">c--</span></tt> be surrogates for this mutual exclusion, since we can easily check if we correctly end up with 0 in the end. Run the code as it is, and you will see that the net value is way off:</p>
<pre class="literal-block">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;condition_variable&gt;
#include &lt;mutex&gt;
#include &lt;chrono&gt;
#include &lt;queue&gt;
using namespace std;

int main() {
    int c = 0;
    bool done = false;
    queue&lt;int&gt; goods;

    thread producer([&amp;]() {
        for (int i = 0; i &lt; 500; ++i) {
            goods.push(i);
            c++;
        }

        done = true;
    });

    thread consumer([&amp;]() {
        while (!done) {
            while (!goods.empty()) {
                goods.pop();
                c--;
            }
        }
    });

    producer.join();
    consumer.join();
    cout &lt;&lt; "Net: " &lt;&lt; c &lt;&lt; endl;
}
</pre>
<p>Don't expect the fix to be that trivial, and feel free to ask the instructor for help. Just wrapping all access to the shared memory in lock-unlock blocks can fix this problem, but remember that we don't want the consumer loop to run amok, taking up resources, so a condition variable is ideal. Use the commands for executing the problem 1000 times to test the integrity of your solution.</p>
</div>
</div>
</div>


</body></html>